
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPS Monte Carlo Simulation</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: rgba(255, 255, 255, 0.98);
            --primary: #0984e3;
            --text-main: #2d3436;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
        }

        /* HUD Stats (Top) */
        .hud-stats {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            padding: 8px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 10;
            font-weight: 600;
            font-size: 1rem;
            pointer-events: none;
            color: var(--text-main);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        canvas {
            display: block;
            width: 100%;
            flex-grow: 1;
            background-color: #ffffff;
            touch-action: none;
        }

        /* Bottom Control Panel */
        .controls {
            background: var(--panel-bg);
            padding: 15px 20px;
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 25px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 20;
        }

        .sliders-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .control-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        label {
            font-size: 0.85rem;
            color: #555;
            display: flex;
            justify-content: space-between;
            font-weight: 500;
        }

        /* Sliders */
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 5px;
            appearance: none;
            background: #e0e0e0;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--primary);
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
        }

        /* Buttons */
        .btn-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
            background-color: var(--primary);
            color: white;
            white-space: nowrap;
        }

        button:active { opacity: 0.8; }
        
        button.secondary { background-color: #dfe6e9; color: #2d3436; flex: 0.4; }
        button.stop { background-color: #d63031; } /* Red for Stop */
        button.monte-carlo { background-color: #6c5ce7; } /* Purple for Monte Carlo */

        /* Monte Carlo Result Overlay */
        #mc-results {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.25);
            text-align: center;
            z-index: 100;
            min-width: 280px;
            color: var(--text-main);
        }
        #mc-results h3 { margin: 0 0 15px 0; font-size: 1.2rem; }
        
        .result-bar {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 1rem;
        }
        
        .bar-bg { flex: 1; height: 12px; background: #eee; border-radius: 6px; margin: 0 12px; overflow: hidden;}
        .bar-fill { height: 100%; transition: width 0.6s cubic-bezier(0.22, 1, 0.36, 1); }
        
        .percentage { width: 45px; text-align: right; font-variant-numeric: tabular-nums; }
    </style>
</head>
<body>

    <!-- HUD Stats -->
    <div class="hud-stats">
        <div class="stat-item"><span>ü™®</span> <span id="count-rock">0</span></div>
        <div class="stat-item"><span>üìÑ</span> <span id="count-paper">0</span></div>
        <div class="stat-item"><span>‚úÇÔ∏è</span> <span id="count-scissors">0</span></div>
        <div class="stat-item" style="color: #888; margin-left: 10px; font-size: 0.9em;">‚è±Ô∏è <span id="timer">0.0</span>s</div>
    </div>

    <!-- Monte Carlo Results Overlay -->
    <div id="mc-results">
        <h3 id="mc-title">üìä Monte Carlo Results</h3>
        
        <div class="result-bar">
            <span>ü™®</span>
            <div class="bar-bg"><div class="bar-fill" id="bar-rock" style="background:#636e72; width:0%"></div></div>
            <span class="percentage" id="res-rock">0%</span>
        </div>
        
        <div class="result-bar">
            <span>üìÑ</span>
            <div class="bar-bg"><div class="bar-fill" id="bar-paper" style="background:#0984e3; width:0%"></div></div>
            <span class="percentage" id="res-paper">0%</span>
        </div>
        
        <div class="result-bar">
            <span>‚úÇÔ∏è</span>
            <div class="bar-bg"><div class="bar-fill" id="bar-scissors" style="background:#d63031; width:0%"></div></div>
            <span class="percentage" id="res-scissors">0%</span>
        </div>

        <div style="margin-top: 15px; font-size: 0.85rem; color: #888;">N=100 Independent Runs</div>
        <button onclick="closeResults()" style="margin-top:15px; width:100%">Close</button>
    </div>

    <canvas id="simCanvas"></canvas>

    <!-- Controls -->
    <div class="controls">
        <div class="sliders-row">
            <div class="control-group">
                <label>Count (N): <span id="lblCount">15</span></label>
                <!-- Limit: 10 - 20 -->
                <input type="range" id="initCount" min="10" max="20" value="15" oninput="updateLabel('lblCount', this.value)">
            </div>
            <div class="control-group">
                <label>Velocity (v): <span id="lblSpeed">8</span></label>
                <!-- Limit: 5 - 10 -->
                <input type="range" id="speedParam" min="5" max="10" value="8" oninput="updateLabel('lblSpeed', this.value)">
            </div>
        </div>
        
        <div class="btn-row">
            <button class="monte-carlo" onclick="runMonteCarlo()">‚ö° 100 Runs Result</button>
            <button id="btnStart" onclick="toggleSimulation()">Start</button>
            <button class="secondary" onclick="resetSimulation()">Reset</button>
        </div>
    </div>

<script>
    // --- Physics Configuration ---
    const TYPE = { ROCK: 0, PAPER: 1, SCISSORS: 2 };
    const ICONS = ['ü™®', 'üìÑ', '‚úÇÔ∏è'];
    
    // Physics Parameters
    const PARTICLE_RADIUS = 14; 
    const COLLISION_COOLDOWN = 15; 

    // --- State ---
    let canvas, ctx;
    let width, height;
    let particles = [];
    let animationId;
    let isRunning = false;
    let startTime;
    
    // User Settings (Defaults)
    let settingCount = 15;
    let settingSpeed = 8;

    class Particle {
        constructor(x, y, type, speed) {
            this.pos = { x: x, y: y };
            this.type = type;
            this.radius = PARTICLE_RADIUS;
            this.cooldown = 0;
            
            // Random Direction Vector
            const angle = Math.random() * Math.PI * 2;
            this.vel = {
                x: Math.cos(angle) * speed,
                y: Math.sin(angle) * speed
            };
        }

        update(w, h) {
            this.pos.x += this.vel.x;
            this.pos.y += this.vel.y;

            const buffer = this.radius; 
            
            // Boundary: Elastic Collision
            if (this.pos.x - buffer < 0) {
                this.pos.x = buffer;
                this.vel.x *= -1;
            } else if (this.pos.x + buffer > w) {
                this.pos.x = w - buffer;
                this.vel.x *= -1;
            }

            if (this.pos.y - buffer < 0) {
                this.pos.y = buffer;
                this.vel.y *= -1;
            } else if (this.pos.y + buffer > h) {
                this.pos.y = h - buffer;
                this.vel.y *= -1;
            }

            if (this.cooldown > 0) this.cooldown--;
        }

        draw(ctx) {
            ctx.font = `${this.radius * 2}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(ICONS[this.type], this.pos.x, this.pos.y);
        }
    }

    // --- Initialization ---
    window.onload = () => {
        canvas = document.getElementById('simCanvas');
        ctx = canvas.getContext('2d', { alpha: false });
        
        resize();
        window.addEventListener('resize', resize);
        resetSimulation();
    };

    function resize() {
        width = window.innerWidth;
        const controlsHeight = document.querySelector('.controls').offsetHeight;
        height = window.innerHeight - controlsHeight;
        
        canvas.width = width;
        canvas.height = height;
        
        if (!isRunning && particles.length > 0) drawScene();
    }

    function updateLabel(id, val) {
        document.getElementById(id).innerText = val;
    }

    // --- Physics Engine (Shared) ---
    function stepPhysics(particleList, w, h) {
        // 1. Update Position
        for (let p of particleList) {
            p.update(w, h);
        }

        // 2. Collision Detection (O(N^2))
        // Acceptable for N <= 20
        for (let i = 0; i < particleList.length; i++) {
            let p1 = particleList[i];
            for (let j = i + 1; j < particleList.length; j++) {
                let p2 = particleList[j];
                
                const dx = p2.pos.x - p1.pos.x;
                const dy = p2.pos.y - p1.pos.y;
                const distSq = dx*dx + dy*dy;
                const minDist = (p1.radius + p2.radius) * 0.9; // Slight overlap allowed

                if (distSq < minDist * minDist) {
                    resolveCollision(p1, p2, dx, dy, Math.sqrt(distSq));
                }
            }
        }
    }

    function resolveCollision(p1, p2, dx, dy, dist) {
        if (dist === 0) dist = 0.1; // Prevent div by zero
        
        // Position Correction
        const overlap = (p1.radius + p2.radius - dist) / 2;
        const nx = dx / dist;
        const ny = dy / dist;
        
        p1.pos.x -= nx * overlap;
        p1.pos.y -= ny * overlap;
        p2.pos.x += nx * overlap;
        p2.pos.y += ny * overlap;

        // Velocity Swap (Elastic)
        const tempVx = p1.vel.x;
        const tempVy = p1.vel.y;
        p1.vel.x = p2.vel.x;
        p1.vel.y = p2.vel.y;
        p2.vel.x = tempVx;
        p2.vel.y = tempVy;

        // Game Logic
        if (p1.type === p2.type) return;
        if (p1.cooldown > 0 || p2.cooldown > 0) return;

        let winner = null, loser = null;
        // Rock(0) > Scissors(2)
        // Paper(1) > Rock(0)
        // Scissors(2) > Paper(1)
        if ((p1.type === 0 && p2.type === 2) || 
            (p1.type === 1 && p2.type === 0) || 
            (p1.type === 2 && p2.type === 1)) {
            winner = p1; loser = p2;
        } else {
            winner = p2; loser = p1;
        }

        loser.type = winner.type;
        p1.cooldown = COLLISION_COOLDOWN;
        p2.cooldown = COLLISION_COOLDOWN;
    }

    // --- Visual Loop ---
    function animate(timestamp) {
        if (!isRunning) return;

        const currentElapsed = (performance.now() - startTime) / 1000;
        document.getElementById('timer').innerText = currentElapsed.toFixed(1);

        // Clear
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, width, height);

        // Physics
        stepPhysics(particles, width, height);
        
        // Render
        for (let p of particles) p.draw(ctx);

        updateStats(particles);
        
        if (checkDomination(particles)) {
            toggleSimulation(); // Pause
            return;
        }

        animationId = requestAnimationFrame(animate);
    }

    // --- Monte Carlo Simulation Logic ---
    function runMonteCarlo() {
        if (isRunning) toggleSimulation(); // Pause visual if running

        const SIMULATIONS = 100;
        const MAX_STEPS = 5000; // Step limit per run to prevent infinite loops
        
        // Get Parameters
        const count = parseInt(document.getElementById('initCount').value);
        const speed = parseInt(document.getElementById('speedParam').value);
        
        let wins = { 0: 0, 1: 0, 2: 0, 'draw': 0 };
        
        // UI Feedback
        const resultsPanel = document.getElementById('mc-results');
        resultsPanel.style.display = 'block';
        document.getElementById('mc-title').innerText = "Calculating...";
        
        // Defer execution to allow UI update
        setTimeout(() => {
            // Run 100 independent simulations
            for (let n = 0; n < SIMULATIONS; n++) {
                
                // 1. Initialize Temp World
                let tempParticles = [];
                for (let type = 0; type < 3; type++) {
                    for (let k = 0; k < count; k++) {
                        const x = Math.random() * (width - 40) + 20;
                        const y = Math.random() * (height - 40) + 20;
                        tempParticles.push(new Particle(x, y, type, speed));
                    }
                }

                // 2. Fast Forward Physics
                let step = 0;
                let winner = -1;
                
                while (step < MAX_STEPS) {
                    stepPhysics(tempParticles, width, height);
                    
                    // Check Winner
                    let counts = [0, 0, 0];
                    tempParticles.forEach(p => counts[p.type]++);
                    let active = counts.filter(c => c > 0).length;
                    
                    if (active === 1) {
                        winner = counts.findIndex(c => c > 0);
                        break;
                    }
                    step++;
                }

                if (winner !== -1) wins[winner]++;
                else wins['draw']++; // Very rare in RPS, usually implies max steps reached
            }

            // Display Results
            showResults(wins, SIMULATIONS);
        }, 50);
    }

    function showResults(wins, total) {
        document.getElementById('mc-title').innerText = "üìä Monte Carlo Results";
        
        const setBar = (id, count) => {
            const pct = Math.round((count / total) * 100);
            document.getElementById('bar-' + id).style.width = pct + '%';
            document.getElementById('res-' + id).innerText = pct + '%';
        };

        setBar('rock', wins[0]);
        setBar('paper', wins[1]);
        setBar('scissors', wins[2]);
    }

    function closeResults() {
        document.getElementById('mc-results').style.display = 'none';
    }

    // --- Helpers ---
    function updateStats(pList) {
        const counts = [0, 0, 0];
        pList.forEach(p => counts[p.type]++);
        document.getElementById('count-rock').innerText = counts[0];
        document.getElementById('count-paper').innerText = counts[1];
        document.getElementById('count-scissors').innerText = counts[2];
        return counts;
    }

    function checkDomination(pList) {
        const counts = [0, 0, 0];
        pList.forEach(p => counts[p.type]++);
        const active = counts.filter(c => c > 0).length;
        
        if (active === 1) {
            // Optional: Draw "Winner" text on canvas
            const winnerIdx = counts.findIndex(c => c > 0);
            const winnerName = ["Rock", "Paper", "Scissors"][winnerIdx];
            
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(0, height/2 - 40, width, 80);
            ctx.fillStyle = "#fff";
            ctx.font = "bold 24px Arial";
            ctx.textAlign = "center";
            ctx.fillText(`Winner: ${winnerName}`, width/2, height/2 + 8);
            ctx.restore();
            
            return true;
        }
        return false;
    }

    function drawScene() {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, width, height);
        particles.forEach(p => p.draw(ctx));
    }

    // --- Controls Logic ---
    function toggleSimulation() {
        const btn = document.getElementById('btnStart');
        if (isRunning) {
            // Pause
            isRunning = false;
            cancelAnimationFrame(animationId);
            btn.innerText = "Resume";
            btn.classList.remove("stop");
        } else {
            // Start
            isRunning = true;
            settingCount = parseInt(document.getElementById('initCount').value);
            settingSpeed = parseInt(document.getElementById('speedParam').value);
            
            // Spawn if empty
            if (particles.length === 0) {
                spawnParticles();
            } else {
                 // Adjust timer offset for resume
                 const currentTimer = parseFloat(document.getElementById('timer').innerText);
                 startTime = performance.now() - (currentTimer * 1000);
            }
            
            if (!startTime) startTime = performance.now();
            
            btn.innerText = "Pause";
            btn.classList.add("stop");
            animate();
        }
    }

    function resetSimulation() {
        isRunning = false;
        cancelAnimationFrame(animationId);
        document.getElementById('btnStart').innerText = "Start";
        document.getElementById('btnStart').classList.remove("stop");
        document.getElementById('timer').innerText = "0.0";
        startTime = null;
        
        settingCount = parseInt(document.getElementById('initCount').value);
        settingSpeed = parseInt(document.getElementById('speedParam').value);
        
        spawnParticles();
        drawScene();
        updateStats(particles);
    }

    function spawnParticles() {
        particles = [];
        for (let type = 0; type < 3; type++) {
            for (let i = 0; i < settingCount; i++) {
                // Padding ensures particles don't spawn stuck in wall
                const x = Math.random() * (width - 40) + 20;
                const y = Math.random() * (height - 40) + 20;
                particles.push(new Particle(x, y, type, settingSpeed));
            }
        }
    }
</script>
</body>
</html>

